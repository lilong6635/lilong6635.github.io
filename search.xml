<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[angular指令介绍]]></title>
    <url>%2F2017%2F07%2F16%2Fangular%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Angular 第3天ng-bind单向绑定数据，类似于innerText操作，会将标签中的内容全部替换！1&lt;p ng-bind="数据"&gt;&lt;/p&gt; ngSanitize ng-bind-htmlngSanitize提供了可以将html代码渲染成dom元素的指令 ng-bind-html使用方式 引入文件 angular-sanitize.js 作为模块的依赖项，引入到模块中 直接使用ng-bind-html即可 ng-show ng-hide ng-if ng-switch ng-switch-when都是布尔值，控制元素的显示和隐藏 ng-show ng-hide 是给元素添加了display:noneng-if 如果是false，就将元素直接删掉了 ng-switch， 只有满足ng-switch-when 条件的才会出现，不满足的就删掉了 ng-submit ng-blur ng-change ng-dblclick 过滤器的使用官方文档 1&lt;p ng-bind="数据 | 过滤器名称 : 过滤器参数 : 过滤器参数 "&gt;&lt;/p&gt; filter过滤器的使用filter过滤器是用来顾虑数组的，所以只能用在数组上1234&lt;p ng-repeat="数据 | filter : 可以直接是一个值"&gt;&lt;/p&gt;当传递一个值的时候，会在数组中对象的所有属性中去查找这个值，如果找到，就筛选出来&lt;p ng-repeat="数据 | filter : 还可以是一个对象"&gt;&lt;/p&gt;当传递一个对象的时候，会在数组中对象的指定的属性（传递的对象的属性名）中去查找这个对象的属性值，如果找到，就筛选出来 过滤器不仅可以通过指令在视图中调用也可以通过js代码来调用 12345//1. 注入$filter服务//2. 调用$filter获取过滤器var currency = $filter("currency");//3. 调用获取到的过滤器对数据进行过滤currency(要过滤的数据, 参数, 参数) 服务的使用123456789101112131415//创建服务angular .module("app", []) .service("服务名称", ["依赖项", function(获取依赖项)&#123; //通过使用this添加内容。来给使用该服务的地方暴露接口 this.方法 = function()&#123;&#125; &#125;]) //使用服务 .controller("c1", ["服务名称", fucntion(获取传入的服务)&#123; 传入的服务.方法()//这里就直接可以调用到服务中的内容了 &#125;])//如果服务和当前要使用服务的内容不在同一的模块中，那么首先需要将包含该服务的模块，作为依赖项引入到要使用该服务的模块当中，再去按照上面的方式使用该服务！ todoMVC案例 展示任务列表 添加任务 删除一条任务 修改任务 切换任务选中状态(单个或批量) 清除已完成任务 显示未完成任务数 显示不同状态的任务以及当前任务高亮处理 根据URL变化显示相应任务]]></content>
      <categories>
        <category>angularjs</category>
        <category>angularjs指令介绍</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular基本指令介绍和闪烁问题]]></title>
    <url>%2F2017%2F07%2F16%2Fangular%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%97%AA%E7%83%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[angular介绍每一个控制器都拥有$scope，这个$scope可以看做是一个作用域，当前控制器中所有绑定的数据内容都会来这个$scope中进行查找 在模块控制的范围内，有一个全局作用域，$rootScope 控制器之间又可以进行嵌套，嵌套之后，作用域之间就形成了继承关系，其原理就是原型继承 继承关系指的就是，绑定数据在查找的时候，会现在当前控制器中进行查找，如果找到了就直接使用，如果找不到就会去外层控制的作用域中进行查找，直到找到$rootScope为止！ $rootScope可以被所有的控制器操作，所以很容易出现全局污染的情况，所以应该避免进行类似的操作 模块创建模块angular.module(“模块名称”, [“依赖项”]); 获取模块angular.module(“模块名称”); 模块注意事项angular推荐一个页面中只使用一个ng-app指定一个模块 如果存在多个ng-app指令，angular只会自动启动第一个模块！ 如果要启动多个模块，需要手动启动1angular.bootstrap(模块要控制的dom元素, ["模块名称"]); ** 模块不能嵌套！！！ MVC一种架构模式，将应用程序代码根据功能划分为三部分Model: 数据内容，负责所有的数据操作View: 视图内容, 负责所有的数据展示工作以及用户交互操作Controller: 控制器内容，负责处理所有的业务逻辑（在视图和数据之间搭建一个桥梁） MVP MVVM MVW MV*jqlitejqlite是angular内置的类似于jQuery的东西，但是他不具备jQuery大部分的功能，尤其是没有选择器，这个让人很难以接受！！ angular.element能够获取到jqlite的对象，也可以在引入jQuery之后，用来获取jQuery的$ angular不推荐进行dom操作，也不推荐使用别人家的东西！！！ $watch$watch可以用来监视数据的变化 只能监视$scope中的内容！123$scope.$watch("数据名称", function(newValue, oldValue)&#123; //这个函数会在数据发生变化的时候被调用&#125;) 如果要监视一个对象，那么需要传入第三个参数，deepwatch，是一个布尔值，设置为true的时候，会在对象内部的属性发生变化的时候也监视到变化，但是他默认值是false！！ controller的创建方式 推断式 12345模块对象.controller("控制器名称", function($scope)&#123; //$scope这个形参名是定死的，不能随便更改，更改之后会找到不到该内容，报错 //这种写法不推荐，因为在代码压缩的时候，$scope会被改变名称！&#125;) 依赖注入式 1模块对象.controller("控制器名称", ["$scope", "$log"..., function(scope, lgo...)&#123;&#125;]) 面向对象的方式 （可以将数据绑定到控制器的实例上） 12345模块对象.controller("控制器名称", function()&#123; //this指向的就是控制器的一个实例， //下面的操作就是将数据绑定到了实例对象上 this.数据 = "neirong";&#125;) 在视图中需要通过如下的方式进行使用12345&lt;!-- 这里的item其实就是控制器实例 --&gt;&lt;!-- 这句话就相当于执行了 var item = new 控制器() --&gt;&lt;div ng-controller="控制器名称 as item"&gt; &#123;&#123;item.数据&#125;&#125;&lt;/div&gt; 依赖注入DI dependence injection将需要使用的内容注入到指定的位置！ 优势： 1. 参数的顺序不需要指定了，参数也不需要将所有的内容都传递进来了 2. 参数名称也不需要定死了 angular当中的依赖注入的实现依赖注入的说明 ng-class可以用来绑定类样式 ng-class=”数据” 数据中存储的可以直接是类名 ng-class=”数据” 数据中存储的是一个对象，对象中的属性名表示类名，属性值表示该类名有没有在元素中出现，是一个布尔值！ng-class=”{red: true, green: false}” ng-repeat用来遍历数据，生成html12345&lt;p ng-repeat="item in list"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;&lt;p ng-repeat="item in list"&gt;&#123;&#123;item&#125;&#125; &#123;&#123;$index&#125;&#125;&lt;/p&gt;&lt;p ng-repeat="(key, value) in list"&gt;&#123;&#123;key&#125;&#125; &#123;&#123;value&#125;&#125;&lt;/p&gt;ng-repeat不仅可以遍历数组，也可以遍历对象 ng-repeat遍历的数组中的内容是不允许重复的，如果想要重复的内容，需要加上track by 12&lt;p ng-repeat="item in list track by 一个唯一的值"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;唯一的值一般使用的就是$index ng-cloak 解决闪烁问题原理: 在angular加载完毕之后, 所有ng-cloak相关的内容全都会被移除 声明ng-cloak的类样式, 或者用属性选择器, 加上display:none 在元素中使用class=”ng-cloak”,或者加上ng-cloak属性 将元素隐藏 在angular加载完毕之后, ng-cloak的类样式和ng-cloak属性都将被移除, 元素显示! 12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .ng-cloak &#123; display: none; &#125; [ng-cloak]&#123; display: none; &#125; .display&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app="app" ng-controller="c1"&gt; &lt;!-- ng-cloak指令会在angular加载完成之后，被移除，所以就利用该特性 --&gt; &lt;!-- 将元素进行隐藏，用类样式也好，属性选择器也好，都可以实现 --&gt; &lt;!-- 自己要去样式列表中手动添加 display:none的样式 --&gt; &lt;p class="ng-cloak"&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p ng-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="angular.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module("app", []) .controller("c1", ["$scope", function(vm)&#123; vm.name = "hello world"; &#125;]) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>angularjs</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的工作原理]]></title>
    <url>%2F2017%2F07%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器工作原理浏览器的组成 人机交互部分（UI） 网络请求部分（Socket） JavaScript引擎部分（解析执行JavaScript） 渲染引擎部分（渲染HTML、CSS等） 数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage） 主流渲染引擎介绍 渲染引擎 又叫 排版引擎 或 浏览器内核。 主流的 渲染引擎 有 Chrome浏览器: Blink引擎（WebKit的一个分支）。 Safari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。 FireFox浏览器: Gecko引擎。 Opera浏览器: Blink引擎(早期版使用Presto引擎）。 Internet Explorer浏览器: Trident引擎。 Microsoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。 工作原理 解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。 构建渲染树，渲染树并不等同于Dom树，因为像head标签 或 display: none这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。 对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫&quot;layout&quot; 或 &quot;reflow&quot;。 绘制渲染树，调用操作系统底层API进行绘图操作。 渲染引擎工作原理示意图渲染引擎工作原理示意图 WebKit工作原理（Chrome、Safari、Opera） Gecko工作原理（FireFox） 浏览器的 reflow 或 layout 过程https://www.youtube.com/watch?v=ZTnIxIA5KGw 打开 Chrome 的 Rendering 功能第一步： 第二步： 浏览器访问网站过程 在浏览器地址栏中输入网址。 浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。 123456789GET / HTTP/1.1Host: www.taobao.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn 浏览器发起DNS解析请求，将域名转换为IP地址。 浏览器将请求报文发送给服务器。 服务器接收请求报文，并解析。 服务器处理用户请求，并将处理结果封装成HTTP响应报文。 1234567891011121314151617181920212223242526272829303132333435HTTP/1.1 200 OKServer: TengineDate: Thu, 13 Apr 2017 02:24:25 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingVary: Ali-Detector-Type, X-CIP-PTCache-Control: max-age=0, s-maxage=300Via: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]Age: 293X-Cache: HIT TCP_MEM_HIT dirn:-2:-2X-Swift-SaveTime: Thu, 13 Apr 2017 02:19:32 GMTX-Swift-CacheTime: 300Timing-Allow-Origin: *EagleId: 9903e7e514920502659594264eStrict-Transport-Security: max-age=31536000Content-Encoding: gzip&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;meta name="renderer" content="webkit" /&gt;&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;&lt;meta name="spm-id" content="a21bo" /&gt;&lt;meta name="description" content="淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！" /&gt;&lt;meta name="aplus-xplug" content="NONE"&gt;&lt;meta name="keyword" content="淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺" /&gt;&lt;/head&gt;&lt;body&gt;......&lt;/body&gt;&lt;/html&gt; 服务器将HTTP响应报文发送给浏览器。 浏览器接收服务器响应的HTTP报文，并解析。 浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。 最终浏览器展示出了页面 通过 csszengarden 来讲解浏览器请求响应全过程CSS禅意花园 HTTP请求报文和响应报文格式 补充知识为什么建立 TCP 连接需要 3 次握手? three-way handshake 是”为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 举例：”已失效的连接请求报文段” 的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 总结：TCP 的三次握手是为了 建立可靠的信道。 DNS 解析过程 windows 下 hosts 文件位置C:\Windows\System32\drivers\etc\hosts DOM 解析参考代码:123456&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;div&gt; &lt;img src="example.png" alt="example"/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Webkit CSS 解析 How Browsers work - 浏览器是如何工作的How Browsers work]]></content>
      <categories>
        <category>nodejs</category>
        <category>浏览器工作原理</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中服务的创建方式]]></title>
    <url>%2F2017%2F07%2F12%2Fangular%E4%B8%AD%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[服务的创建方式 service 12345678910模块对象 .service("服务名", ["注入服务", function(注入的服务)&#123; //通过this给服务添加属性和方法，最终提供给调用服务的人使用 //最终用户获取到的服务对象，其实就是使用本函数，构造出来 //也就是说用new的方式创建出来的 this.数据: 数据 this.方法= function()&#123; &#125; &#125;]) factory 12345678910模块对象 .factory("服务名", ["注入服务", function(注入的服务)&#123; //通过给obj对象添加属性和方法，最终提供给调用服务的人使用 //最终用户获取到的服务对象，其实就是使用本函数，使用工厂模式创建的 var obj = &#123;&#125;; 数据: 数据, 方法: function()&#123; &#125; return obj; &#125;]) value 12模块名称 .value("服务名称", &#123;//最终提供服务的对象，就是本对象！&#125;) constant 12模块名称 .constant("服务名称", &#123;//最终提供服务的对象，就是本对象！&#125;) provider 12345678910111213模块名称 .provider("服务名称", function()&#123; //这里可以声明一些变量，来保存服务的配置信息！ return &#123; //这个对象其实就是在config方法中获取到的 服务Provider 对象 //这个对象中必须包含一个$get方法 $get: function()&#123; return &#123; //这个对象就是最终的服务对象，用户所使用的服务就是本对象！ &#125; &#125; &#125; &#125;) Dirty-Check 脏检查机制，ng双向数据绑定的原理在angular初始化的时候，会先创建模块对象，初始化该模块，初始化模块的时候，会在该模块所管辖的view范围内，搜索所有的ng指令，找到指令之后，为每一个指令绑定一个$watcher,这个watcher会在数据或者dom元素发生改变的时候，被调用！每当有一个watcher被触发，那么就会开启一次新的$digest, $digest中，会对所有的$watcher，一次执行来检测是否有数据变化，如果有变换，会重新启动一次$digest, 依次循环，直到检测不到任何变化为止，最终开始更新dom操作！！ $apply 其实就是将相应的操作做了一个包装，先执行只写操作，然后再去调用$digest开始在脏检查 在angular中angular负责的所有的内容，都会默认的被$apply进行包裹，如果使用到了非angular控制的内容，比如setTimeout， 在这个里面的数据操作，将不会触发watcher，也就不会进行脏检查，所以，我们需要手动进行在脏检查 调用$apply来执行数据操作 123$scope.$apply(function()&#123; //做需要的数据操作&#125;) 做完数据操作之后，手动调用$digest方法 12//做完数据操作$scope.$digest(); angular-route使用步骤： 引入angular-route.js文件 在使用该angular-route模块的模块中加入依赖项 ngRoute 在模块的config方法中对angular-route进行配置 配置需要注入的内容为 $routeProvider 使用when方法进行配置12345678910111213141516171819202122232425262728angular .module("app", ["ngRoute"]) .config(["$routeProvider", function($routeProvider)&#123; $routeProvider.when("hash路径匹配规则", &#123; template: "视图html代码", //template属性和templateUrl只需要并且必须存在一个！ templateUrl: "视图路径", controller: "控制器" &#125;) //路由传参 在路由规则当中指定传参的形式，以及参数的名称 .when("hash路径/:参数名称", &#123; template: "视图html代码", templateUrl: "视图路径", controller: "控制器" &#125;) .otherwise(&#123; //这里做的就是当所有的匹配规则都不满足的情况下做的事情 //redierctTo: 就是进行路径跳转的操作 redirectTo: "hash路径" &#125;) &#125;]) //获取路由传进来的参数 .controller("c1", ["$route", "$routeParams", function($route, $routeParams)&#123; //1. 通过$route服务获取 $route.current.pathParams; //1. 通过$routeParams服务获取 $routeParams; &#125;]) 更改哈希路径前的字符 #!/ 感叹号这个东西是在1.6之后默认会加上的1234.config(["$locationProvider", function($locationProvider)&#123; //hashPrefix可以更改上面那个感叹号， 如果不想要就给空字符串 $locationProvider.hashPrefix("");&#125;])]]></content>
      <categories>
        <category>angular</category>
        <category>service</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>webfront</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular基本介绍]]></title>
    <url>%2F2017%2F07%2F10%2Fangular%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[AngularAngular是个框架功能：HTML代码在展示静态页面的功能上非常强大，但是如果涉及到动态数据展示，那么HTML代码就显得非常无力了。Angular这个框架，就是给HTML扩展了新的功能，让他可以支持动态数据展示！ 在html标签当中可以直接使用Angular的指令，将html元素和数据进行绑定。数据更新元素就会相应的更新 使用angular之后，几乎没有任何的DOM操作了 angular适用于CRUD项目，如果说项目中DOM特别复杂并且频繁，那么angular就不适用了！ angular一般被用来创建单页面应用！ SPASingle Page Application单页面应用 整个网站只有一个页面，类似于一个客户端！ 和多页面应用的区别 单页面应用页面只会加载一次，之后的页面中内容的更改，都是通过ajax向后台发送数据请求，拿到数据之后，对页面内容进行更新 多页面应用，每次用户切换功能，都会将整个页面重新加载，跳转到新的页面 单页面应用的优点 无刷新加载页面，用户体验好一些 请求数据会大大减少，提升页面加载的速度 实现多页面应用没法实现的功能，音乐在不同页面之间的连续播放缺点:不利于seo优化 单页面应用的实现原理通过判断当前页面的url地址中hash值的变化，来改变页面中的内容展示 onhashchange这个事件可以用来监听hash值的改变 location.hash这个属性可以用来获取当前页面url中的hash部分 可以在onhashchange事件当中通过location.hash获取到hash值，根据不同的hash值对页面内容进行相应更改。 Angular基本使用指令123451. ng-app 设置模块控制的区域2. ng-controller 设置控制器控制的区域3. ng-model 一般用来将表单元素和数据进行双向绑定4. ng-click 注册点击事件5. &#123;&#123;&#125;&#125; 插值表达式 模块创建123456var app = angular.module("模块名称", []);//第二个参数的数组中放的是当前模块的依赖项//如果没有依赖项，那么也必须写一个空数组//获取已经创建好的模块var app = angular.module("模块名称") 创建控制器1234模块对象.controller("控制器名称", function($scope)&#123; //$scope当前控制器范围内的数据模型 //当前控制器要执行的功能代码&#125;) 步骤 引入angular.js 创建模块，创建控制器 指定模块以及控制器的作用范围 在范围内书写ng- 指令，进行元素和数据之间的绑定 $rootScope1234567891011//1. app.run(function($rootScope)&#123; //这个$rootScope就可以操作app控制区域内的数据模型&#125;)//2. app.controller("c1", function($scope, $rootScope)&#123; //$rootScope在所有的controller中都可以使用 //所以可能会造成全局污染 //所以一般不在controller中使用它！&#125;)]]></content>
      <categories>
        <category>angular</category>
        <category>基本介绍</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>webfront</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中模块的作用域和控制器依赖注入的介绍]]></title>
    <url>%2F2017%2F07%2F10%2Fangular%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[作用域每一个控制器都拥有$scope，这个$scope可以看做是一个作用域，当前控制器中所有绑定的数据内容都会来这个$scope中进行查找 在模块控制的范围内，有一个全局作用域，$rootScope 控制器之间又可以进行嵌套，嵌套之后，作用域之间就形成了继承关系，其原理就是原型继承 继承关系指的就是，绑定数据在查找的时候，会现在当前控制器中进行查找，如果找到了就直接使用，如果找不到就会去外层控制的作用域中进行查找，直到找到$rootScope为止！ $rootScope可以被所有的控制器操作，所以很容易出现全局污染的情况，所以应该避免进行类似的操作 模块创建模块angular.module(“模块名称”, [“依赖项”]); 获取模块angular.module(“模块名称”); 模块注意事项angular推荐一个页面中只使用一个ng-app指定一个模块 如果存在多个ng-app指令，angular只会自动启动第一个模块！ 如果要启动多个模块，需要手动启动1angular.bootstrap(模块要控制的dom元素, ["模块名称"]); ** 模块不能嵌套！！！ MVC一种架构模式，将应用程序代码根据功能划分为三部分Model: 数据内容，负责所有的数据操作View: 视图内容, 负责所有的数据展示工作以及用户交互操作Controller: 控制器内容，负责处理所有的业务逻辑（在视图和数据之间搭建一个桥梁） MVP MVVM MVW MV*jqlitejqlite是angular内置的类似于jQuery的东西，但是他不具备jQuery大部分的功能，尤其是没有选择器，这个让人很难以接受！！ angular.element能够获取到jqlite的对象，也可以在引入jQuery之后，用来获取jQuery的$ angular不推荐进行dom操作，也不推荐使用别人家的东西！！！ $watch$watch可以用来监视数据的变化 只能监视$scope中的内容！123$scope.$watch("数据名称", function(newValue, oldValue)&#123; //这个函数会在数据发生变化的时候被调用&#125;) 如果要监视一个对象，那么需要传入第三个参数，deepwatch，是一个布尔值，设置为true的时候，会在对象内部的属性发生变化的时候也监视到变化，但是他默认值是false！！ controller的创建方式 推断式 12345模块对象.controller("控制器名称", function($scope)&#123; //$scope这个形参名是定死的，不能随便更改，更改之后会找到不到该内容，报错 //这种写法不推荐，因为在代码压缩的时候，$scope会被改变名称！&#125;) 依赖注入式 1模块对象.controller("控制器名称", ["$scope", "$log"..., function(scope, lgo...)&#123;&#125;]) 面向对象的方式 （可以将数据绑定到控制器的实例上） 12345模块对象.controller("控制器名称", function()&#123; //this指向的就是控制器的一个实例， //下面的操作就是将数据绑定到了实例对象上 this.数据 = "neirong";&#125;) 在视图中需要通过如下的方式进行使用12345&lt;!-- 这里的item其实就是控制器实例 --&gt;&lt;!-- 这句话就相当于执行了 var item = new 控制器() --&gt;&lt;div ng-controller="控制器名称 as item"&gt; &#123;&#123;item.数据&#125;&#125;&lt;/div&gt; 依赖注入DI dependence injection将需要使用的内容注入到指定的位置！ 优势： 1. 参数的顺序不需要指定了，参数也不需要将所有的内容都传递进来了 2. 参数名称也不需要定死了 angular当中的依赖注入的实现依赖注入的说明 ng-class可以用来绑定类样式 ng-class=”数据” 数据中存储的可以直接是类名 ng-class=”数据” 数据中存储的是一个对象，对象中的属性名表示类名，属性值表示该类名有没有在元素中出现，是一个布尔值！ng-class=”{red: true, green: false}” ng-repeat用来遍历数据，生成html12345&lt;p ng-repeat="item in list"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;&lt;p ng-repeat="item in list"&gt;&#123;&#123;item&#125;&#125; &#123;&#123;$index&#125;&#125;&lt;/p&gt;&lt;p ng-repeat="(key, value) in list"&gt;&#123;&#123;key&#125;&#125; &#123;&#123;value&#125;&#125;&lt;/p&gt;ng-repeat不仅可以遍历数组，也可以遍历对象 ng-repeat遍历的数组中的内容是不允许重复的，如果想要重复的内容，需要加上track by 12&lt;p ng-repeat="item in list track by 一个唯一的值"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;唯一的值一般使用的就是$index ng-cloak 解决闪烁问题原理：在angular加载完毕之后，所有ng-cloak相关的内容全都会被移除 声明ng-cloak的类样式，或者用属性选择器，加上display:none 在元素中使用class=”ng-cloak”，或者加上ng-cloak属性 将元素隐藏 在angular加载完毕之后，ng-cloak的类样式和ng-cloak属性都将被移除，元素显示！]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>依赖注入</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中ng-bind和ng-filter指令的使用]]></title>
    <url>%2F2017%2F07%2F10%2Fangular%E4%B8%ADng-bind%E5%92%8Cng-filter%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ng-bind单向绑定数据，类似于innerText操作，会将标签中的内容全部替换！1&lt;p ng-bind="数据"&gt;&lt;/p&gt; ngSanitize ng-bind-htmlngSanitize提供了可以将html代码渲染成dom元素的指令 ng-bind-html使用方式 引入文件 angular-sanitize.js 作为模块的依赖项，引入到模块中 直接使用ng-bind-html即可 ng-show ng-hide ng-if ng-switch ng-switch-when都是布尔值，控制元素的显示和隐藏 ng-show ng-hide 是给元素添加了display:noneng-if 如果是false，就将元素直接删掉了 ng-switch， 只有满足ng-switch-when 条件的才会出现，不满足的就删掉了 ng-submit ng-blur ng-change ng-dblclick过滤器的使用官方文档 1&lt;p ng-bind="数据 | 过滤器名称 : 过滤器参数 : 过滤器参数 "&gt;&lt;/p&gt; filter过滤器的使用filter过滤器是用来顾虑数组的，所以只能用在数组上1234&lt;p ng-repeat="数据 | filter : 可以直接是一个值"&gt;&lt;/p&gt;当传递一个值的时候，会在数组中对象的所有属性中去查找这个值，如果找到，就筛选出来&lt;p ng-repeat="数据 | filter : 还可以是一个对象"&gt;&lt;/p&gt;当传递一个对象的时候，会在数组中对象的指定的属性（传递的对象的属性名）中去查找这个对象的属性值，如果找到，就筛选出来 过滤器不仅可以通过指令在视图中调用也可以通过js代码来调用 12345//1. 注入$filter服务//2. 调用$filter获取过滤器var currency = $filter("currency");//3. 调用获取到的过滤器对数据进行过滤currency(要过滤的数据, 参数, 参数) 服务的使用123456789101112131415//创建服务angular .module("app", []) .service("服务名称", ["依赖项", function(获取依赖项)&#123; //通过使用this添加内容。来给使用该服务的地方暴露接口 this.方法 = function()&#123;&#125; &#125;]) //使用服务 .controller("c1", ["服务名称", fucntion(获取传入的服务)&#123; 传入的服务.方法()//这里就直接可以调用到服务中的内容了 &#125;])//如果服务和当前要使用服务的内容不在同一的模块中，那么首先需要将包含该服务的模块，作为依赖项引入到要使用该服务的模块当中，再去按照上面的方式使用该服务！ todoMVC案例 展示任务列表 添加任务 删除一条任务 修改任务 切换任务选中状态(单个或批量) 清除已完成任务 显示未完成任务数 显示不同状态的任务以及当前任务高亮处理 根据URL变化显示相应任务]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>ng-bind</tag>
        <tag>ng-filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-validate]]></title>
    <url>%2F2017%2F07%2F07%2Fjquery-validate%2F</url>
    <content type="text"><![CDATA[jquery-validate插件的使用介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// validate方法是注册一个验证事件// 而不是说调用该方法才会验证！$("form").validate(&#123; sendForm: false, // onKeyup: true, // onBlur: true, // onChange: true, // onSubmit: false, // valid: function()&#123; // //当整个表单通过验证的时候，会调用该回调方法 // console.log("验证通过了"); // &#125;, // invalid: function()&#123; // console.log("验证不通过"); // &#125;, // eachField: function()&#123; // console.log("eachField被调用了", this); // &#125;, eachValidField: function()&#123; // console.log("eachValidField,被调用了", this); this.next().show().removeClass("error").addClass("success"); &#125;, eachInvalidField: function()&#123; // console.log("eachInvalidField,被调用了", this); this.next().show().removeClass("success").addClass("error"); &#125;, conditional: &#123; "isShuaiGe": function()&#123; return this.val() == "潘明"; &#125;, "isBeauty": function()&#123; return this.val() == "教主"; &#125; &#125;, description: &#123; "username": &#123; required: "用户名不能为空", conditional: "你输入的不是美女", valid: "输入正确！" &#125;, "phone": &#123; pattern: "手机号码不正确", required: "请输入手机号码", valid: "输入正确" &#125; &#125;&#125;);]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>plugs</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uploadify的使用总结]]></title>
    <url>%2F2017%2F07%2F07%2Fuploadify%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[uploadify插件的使用总结 引包 123&lt;link rel="stylesheet" href="uploadify/uploadify.css"&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="uploadify/jquery.uploadify.js"&gt;&lt;/script&gt; 调用uploadify提供的方法 1&lt;input type="file" id="file"&gt; 1234567891011121314151617181920212223242526272829303132$("#file").uploadify(&#123; //指定swf文件的路径！！！ 推荐使用绝对路径 swf: "/views/assets/uploadify/uploadify.swf", //指定上传文件的接口地址 uploader: "/api/uploader/avatar", //指定上传文件的时候，文件的键， 后台需要通过该值来获取文件的内容 fileObjName: "tc_avatar", //尺寸 width: 100, height: 100, //类样式，附加一个类样式给上传按钮 buttonClass: "类名", //按钮的文字 buttonText: "上传图片", //设置上传图片的大小限制，可以是一个字符串单位可以是B KB MB GB fileSizeLimit: "100KB", //设置上传文件的类型，也就是在选择文件的窗口中筛选指定类型的文件 fileTypeExts: '*.gif; *.jpg; *.png', //formData 在上传文件的时候，可以附带一些数据，类似于ajax提交数据 formData: &#123;key: value&#125;, //设置上传进度的模板！ itemTemplate : '&lt;p&gt;&lt;/p&gt;' //onUploadSuccess 上传成功之后的回调函数 onUploadSuccess: function(file, data, response)&#123; &#125;, //onUploadComplete //onUploadError //onUploadProgress //onUploadStart //onUploadSuccess&#125;);]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>plugs</tag>
        <tag>uploadify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立即执行函数表达式/数组的方法]]></title>
    <url>%2F2017%2F07%2F07%2F%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[立即执行函数表达式将函数表达式直接加上()进行调用。tip: 只要函数能被当做表达式，就可以直接加()调用写法： (function(){})() (funciton(){}()) function(){}() function(){}() ! function(){}() ~ function(){}() ^ function(){}() 沙箱模式一个隔离的环境12345678(function(window)&#123; //变量的声明 //功能代码 //如果需要，就通过window对象向外界暴露接口 //window.jQuery = window.$ = jQuery&#125;)(window) 传参的目的 为了实现逻辑上的隔离，沙箱内部不使用外部的内容，外部也不使用沙箱内部的内容 便于代码压缩，因为内置对象无法被压缩，如果使用传参的方式，便可以压缩掉自己定义的这个形参 沙箱模式的用途 框架 类库 插件 组件 数组的方法 forEach 1234567数组.forEach(function(value, index, arr)&#123; &#125;)//遍历数组，遍历到每个元素的时候，都会调用这个回调函数，//value： 当前正在遍历的元素//index: 当前正在遍历的元素的索引//arr； 当前正在遍历的数组对象 map 12345678910数组.map(function(value, index, arr)&#123; &#125;)//遍历数组，遍历到每个元素的时候，都会调用这个回调函数，//value： 当前正在遍历的元素//index: 当前正在遍历的元素的索引//arr； 当前正在遍历的数组对象//map方法有返回值：//每次调用回到函数，都会产生一个返回值，将所有调用返回的返回值组合成一个新的数组，就是map方法的返回值了 filter12345678数组.filter(function(value, index, arr)&#123; &#125;)//遍历数组，遍历到每个元素的时候，都会调用这个回调函数，如果回调函数返回的是true，则当前元素会被加入到返回值数组当中//value： 当前正在遍历的元素//index: 当前正在遍历的元素的索引//arr； 当前正在遍历的数组对象 函数的四种调用模式 函数调用模式 12函数名();//this ---&gt; window 方法调用模式 123对象名.方法名();对象名[方法名]();//this ---&gt; 调用该方法的对象 构造函数调用模式 12new 函数名();//this ---&gt; new创建出来的对象 上下文调用模式 12函数名.call();函数名.apply(); 上下文调用模式上下文调用模式中可以改变函数中this的指向！ call1234函数名.call(obj, arg1...argN);//1. 调用该函数//2. 将函数中的this指向obj//3. 将call方法的第二个及以后所有的实参，依次传递给函数作为实参 apply1234函数名.apply(obj, 数组或者伪数组);//1. 调用该函数//2. 将函数中的this指向obj//3. 将第二个参数中的数组或者伪数组中的元素，拆解开依次传递给函数作为实参 上下文调用模式的应用 伪数组转数组 数组求最大值 借用方法 创建对象的两种模式 工厂模式 123456789function Person()&#123; var obj = &#123;&#125;; obj.name = ""; obj.age = 18; return obj;&#125;//this---&gt;window 因为调用模式是函数调用模式var p = Person(); 寄生模式 123456789function Person()&#123; var obj = &#123;&#125;; obj.name = ""; obj.age = 18; return obj;&#125;//this---&gt;new创建出来的对象 因为调用模式是构造函数调用模式var p = new Person(); 严格模式严格模式如何开启12"use strict"'use strict' 严格模式的特征 声明变量必须使用var 函数的形参不可以重名 ES6之前 对象的属性名不可以重名 eval函数有自己的作用域 不允许使用8进制数字 Object.defineProperty12345678//可以为对象添加属性，并且设置属性的特性Object.defineProperty(obj, propName, descriptor);//descriptor对象的属性说明 //writable： 设置属性是否可以被赋值，默认为false //configurable: 设置属性是否可以被删除，默认为false //enumerable: 设置属性是否可以被遍历，默认为false //value: 设置属性的值（默认值） //get set: 属性的设置器和获取器 两个方法，分别会在属性被赋值和取值的时候，被系统自动调用，不能和writable和value同时存在！]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的闭包]]></title>
    <url>%2F2017%2F07%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包概念闭包指的就是那些能够访问独立的变量的函数！ 闭包要解决的问题函数中声明的变量不能被函数外部直接使用 闭包的基本模型1234567function outer()&#123; var data = ""; function inner()&#123; //操作data &#125; return inner;&#125; 使用闭包设置和获取变量的值123456789101112function outer()&#123; var data = ""; var obj = &#123; setData: function(value)&#123; data = value; &#125;, getData: function()&#123; return data; &#125; &#125; return obj;&#125; 闭包的原理就是作用域的访问规则！ 闭包的作用 给函数提供一个私有的变量 保护变量，给变量的设置提供专有的渠道，在这个渠道中可以添加一些校验的逻辑 闭包的应用 for循环中注册点击事件的问题 for循环中setTimeout的问题 缓存 浏览器缓存 CDN 硬件缓存 缓存封装1234567891011121314function createCache()&#123; var cache = &#123;&#125;; var keys = []; return function(key, value)&#123; if(value)&#123; cache[key] = value; if(keys.push(key) &gt; 20)&#123; delete[keys.shift()]; &#125; &#125;else&#123; return cache[key]; &#125; &#125;&#125; jQuery缓存源码123456789function createCache()&#123; var keys = []; function cache(key, value)&#123; if(keys.push(key + " ") &gt; 20)&#123; delete cache[keys.shift()]; &#125; return (cache[key + " "] = value); &#125;&#125; 递归实现的斐波那契数列存在的性能问题由于存在大量的重复的计算，所以导致在40多之后，就算不出来了 解决方案 提供一个缓存，用这个缓存来存储计算出来的数据 每次在计算的时候，首先先从缓存中去获取,如果有，就直接返回 如果没有，就通过递归的方式去计算 计算出来之后，一定要记着保存到缓存中去，以便下次使用 1234567891011121314151617181920212223242526272829function createCache()&#123; var cache = &#123;&#125;; var keys = []; return function(key, value)&#123; if(value)&#123; cache[key] = value; if(keys.push(key) &gt; 20)&#123; delete[keys.shift()]; &#125; &#125;else&#123; return cache[key]; &#125; &#125;&#125;var cache = createCache();function fib(n)&#123; var num = cache(n); if(!num)&#123; if(n == 1 || n == 2)&#123; num = 1; &#125;else&#123; num = fib(n - 1) + fib(n - 2); &#125; cache(n, num); &#125; return num;&#125;]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归/作用域/变量提升]]></title>
    <url>%2F2017%2F07%2F07%2F%E9%80%92%E5%BD%92-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[伪数组拥有数组通过数字作为下标访问元素的特征，并且拥有length属性，但是没有数组方法的对象就称作伪数组 arguments对象arguments对象是函数中的一个伪数组，在函数被调用的时候，会把所有的实参存到这个伪数组当中 属性 length: 传入的实参的个数 callee: arguments对象所在的函数，一般被用来实现递归！ 如何通过arguments对象实现重载？递归概念函数中直接或者间接的调用自己 两大要素 自己调用自己 结束条件 化归思想化归思想，将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 递归解决数学问题 前n项和 n! 求幂 求斐波那契数列的第n项 递归获取后代元素 先获取元素的所有的子元素 再去获取子元素的子元素，依次递归就可以获取到所有的后代元素123456789101112131415161718192021var list = [];function getChildren(ele)&#123; var children = ele.children; for(var i = 0; i &lt; children.length; i++)&#123; var child = children[i]; list.push(child); getChilren(child); &#125;&#125;function getChildren(ele)&#123; var list = []; var children = ele.children; for(var i = 0; i &lt; children.length; i++)&#123; var child = children[i]; list.push(child); var temp = getChilren(child); list = list.concat(temp); &#125; return list;&#125; 作用域变量起作用的范围 JS里面只有function（函数）可以创建作用域 JS中的作用域是词法作用域（静态作用域）变量的作用域只和函数的声明位置有关，和函数的调用无关！代码在写出来之后，就可以根据代码的书写结构确定变量的作用域，而不需要关心具体的运行的时候的状况。123456789var num = 123;function f1()&#123; console.log(num);&#125;funciton f2()&#123; var num = 456; f1();&#125;f2(); 块级作用域： js中没有块级作用域， 块级作用域就是代码块限定的作用域！ 作用域链函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域嵌套作用域的链式访问结构，叫做作用域链！ 变量搜索原则当使用一个变量的时候 现在当前使用该变量的作用域中进行查找，找该变量的声明，如果有，就直接使用 如果没有就去上一级作用域中进行查找，找该变量的声明，如果有，就直接使用 如果没有，就继续沿着作用域链向上查找，直到找到全局作用域为止 变量提升js代码执行分两个阶段 预解析阶段 执行阶段 在预解析阶段，系统会将所有的变量声明，以及函数声明提升到其所在的作用域的最顶上，这个过程就叫做变量提升。 变量提升的特殊情况 函数同名： 都提升，后面的会把前面的覆盖掉 函数和变量同名： 只提升函数声明，忽略掉变量声明 变量提升是分作用域的，变量和函数的声明，只会被提升到其所在的作用域的最顶上 变量提升是分段(script标签)的， 在当前script标签中的声明，只会被提升到当前script标签的最顶上，不会跨标签提升 条件式函数声明（在条件语句中声明的函数）：会被当做函数表达式来处理，只提升函数名，不提升函数体！ （条件式函数声明不推荐使用！） 函数的形参： 在预解析之前，就已经完成了函数的形参的声明以及赋值，所以形参的声明和赋值不参与变量提升！ 变量提升的面试题！]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链对象都有原型，原型也是对象，原型也有原型，这样就形成了原型组成链条结构，称为原型链。 Object.prototypeObject.prototype是js中所有对象的原型链的最终一环，null标志着原型链的结束！Object.prototype中的所有的成员可以被js中所有的对象共享！ 属性搜索原则当使用对象访问一个属性的时候 现在对象本身进行查找，如果有，就直接使用 如果没有，就去对象的原型中进行查找，如果有，就直接使用 如果没有，就继续沿着原型链向上查找，直到找到为止，或者找到null为止 Object.prototype的成员 名称 说明 hasOwnProperty 判断对象本身是否拥有某个属性, 对象.hasOwnProperty(属性名) isPrototypeOf 判断当前对象是不是另外一个对象的原型 对象.isPrototypeOf(对象) propertyIsEnumerable 判断属性是否属于对象本身并且可以被for-in遍历 对象.propertyIsEnumerable(属性名) toString toLocaleString 将对象转换成字符串的，toLocaleString会将对象转成本地格式的字符串 valueOf 获取对象的值，一般用在值类型和引用类型运算的时候 函数的创建方式函数声明1function 函数名()&#123;&#125; 函数表达式1var 函数名 = function()&#123;&#125;; Function1var 函数名 = new Function(); Function不传参创建出来的是一个空函数，没有任何的功能1var func = new Function(); 传一个参数12var func = new Function(methodBody);//methodBody是一个字符串，里面是符合js语法规范的js代码！会被作为函数体创建新的函数！ 传多个参数123var func = new Function(arg1, arg2...argN, methodBody);//arg1...argN 都是形参的名称， 是字符串！//methodBody是一个字符串，里面是符合js语法规范的js代码！会被作为函数体创建新的函数！ eval（了解）eval可以将字符串转换成代码并直接执行， Funciton创建出来的是函数，需要调用才能执行！ 解析JSON格式的字符串123456789//如果直接将json格式的字符串传递给eval使用，eval会把&#123;&#125;当做代码块处理，报错！var jsonStr = '&#123;"name": "吴彦祖", age: 18&#125;';//解决办法：//1. 把变量的声明也作为字符串传递给evaleval("var obj = " + jsonStr);//2. 在json格式的字符串前后拼接()var o = eval("(" + jsonStr + ")"); Function和eval都有安全性问题！一般情况下不会使用这两个东西！ 函数的原型链函数也是一个对象，函数的构造函数是Function，所以可以分析出函数的原型链 函数 —-&gt; Function.prototype —&gt; Object.prototype —&gt; null 完整的原型链将对象的原型链和函数的原型链结合在一起就绘制成完整的原型链 绘制步骤 绘制对象的原型链 1.1. 绘制对象的构造函数 1.2. 绘制对象的构造函数的原型 1.3. 绘制对象本身 1.4. 绘制3者的三角关系 1.5. 继续沿着构造函数的原型链向上绘制，直到null为止 将构造函数当做对象，绘制函数的原型链 2.1. 绘制函数的构造函数Function 2.2. 绘制Function.prototype 2.3. 绘制3角关系 2.4. 继续沿着Function.prototype的原型向上绘制，直到null为止 绘制Object构造函数 3.1 找到Object构造函数和Object.prototype之间的关系绘制 3.2 将Object当做对象，找到和其构造函数Function的关系，以及原型的关系 将Function当做对象，绘制其原型链 instanceof 关键字12345678910对象 instanceof 构造函数//判断构造函数.prototype是不是在对象的原型链上//Object ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; nullconsole.log(Object instanceof Function);console.log(Object instanceof Object);//Function ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; nullconsole.log(Function instanceof Object);console.log(Function instanceof Function); 函数的成员 name : 函数的名称 length: 函数的形参的个数 caller： 函数是在哪个函数中被调用的，caller就指向那个外部函数（这个caller必须要在函数中去使用，才能访问到值！） arguments： 函数在被调用的时候，会把所有的实参存到这个对象里面（这个对象必须要在函数中去使用，才能访问到值！ 这个arguments是函数的属性，和之前学过的arguments不一样！） 静态成员和实例成员 静态成员： 通过构造函数访问的成员就是静态成员 实例成员： 通过实例对象访问的成员就是实例成员]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础知识]]></title>
    <url>%2F2017%2F07%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[JavaScript的组成 DOM: Document Object Model 提供了一整套操作页面元素的API BOM: Browser Object Model 提供了一整套操作浏览器相关内容的API ECMAScript: js的语法规范以及标准！ JavaScript中的数据类型基本数据类型 string number boolean 复合数据类型 Object function Array Date RegExp String Number Boolean Math 空类型 null undefined 获取数据类型的方式1234567var res = typeof 数据;//typeof关键字可以用来获取数据的数据类型，他的返回值表示数据的数据类型，返回值是一个字符串类型的值//typeof关键字获取除了function以外所有的引用类型的数据的类型的时候，获取到的都是 object//typeof null 获取到的是 object//typeof undefined 获取到的是 undefined 全等和等于的区别全等即判断数据的数据类型是否一致，也判断值是否一致 等于只判断值是否一样 引用类型和值类型参与运算的时候的规则12345678console.log([] == ![]);//1. console.log([] == false);//2. console.log([].valueOf() == false);//3. console.log([].toString() == false);//4. console.log("" == false);console.log(&#123;&#125; + 1);console.log(&#123;&#125; == !&#123;&#125;); 当值类型和数据和引用类型的数据发生运算的时候，首先需要调用该引用类型数据的valueOf方法，获取返回之后，尝试进行运算，如果可以运算，则得出结果，如果不能运算，继续调用该引用类型数据的toString方法，获取返回值，参与运算！ in关键字的使用for-in 用来遍历对象的属性123for(var k in obj)&#123; console.log(k); //k 代表的就是对象的属性，这个k是字符串类型&#125; 属性名 in 对象 判断对象能否访问指定的属性12var obj = &#123;name: "xyz"&#125;;console.log("name" in obj); delete关键字的使用删除没有使用var声明的变量1delete 变量名; 删除对象的属性12delete 对象名.属性delete 对象名[属性] tip: 访问一个不存在的变量，会报错，xx is not defined访问一个对象不存在的属性，不会报错，会返回undefined 逻辑中断||中断12表达式1||表达式2//如果表达式1为真，则返回表达式1，否则返回表达式2 &amp;&amp; 中断12表达式1&amp;&amp;表达式2//如果表达式1为假，则返回表达式1，否则返回表达式2 break和continuebreak 跳出整个循环，继续执行循环之后的代码continue 跳出本次循环， 执行下次循环异常处理语句123456789try&#123; //可能出现错误的代码&#125;catch(e)&#123; //出错后的处理代码 //e 就出错的错误信息&#125;finally&#123; //无论是否出错都会执行的代码 //一般情况下放释放资源的代码&#125; 手动抛出异常12throw anything;//throw可以手动抛出异常，可以抛出任何东西，throw出去的内容如果有trycatch语句，就会被catch捕获，catch中的e就是我们跑出去的异常信息 引用类型和值类型值类型存储的是数据本身的这种数据，就是值类型的数据 引用类型存储的是数据的地址，数据单独存储，这种数据，就是引用类型的数据 值类型和引用类型的赋值特征值类型值类型赋值，会将当前变量存储的数据直接复制一份交给新的变量，此时两个变量内容相同，但是存储空间完全独立，互不影响 引用类型赋值， 会将当前变量存储的数据的地址复制一份，交给新的变量，两个变量指向同一个对象，修改其中一个，另外一个也受到影响 对象的动态特性在对象创建完成之后，可以随时为对象新增成员（属性和方法）这种特性就是动态特性 调试工具的使用（练习）面向对象的基本概念面向过程解决问题的思维方式， 将解决问题的关注点方法在了解决问题的每一个详细的步骤上！ 面向对象解决问题的思维方式， 将解决问题的关注点方法在了解决问题所需要的一系列的对象身上！ 面向对象和面向过程的关系面向对象其实就是对面向过程的封装 什么是对象万物皆对象js中，无序的键值对集合，就是对象！]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>basic data type</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数及原型]]></title>
    <url>%2F2017%2F07%2F07%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程举例 初步实现（面向过程的方式） 函数封装 对象封装 创建对象的方式 字面量 12345678var obj = &#123; key: value, key1: value1&#125;;//$().css(&#123;&#125;)//$.ajax(&#123;&#125;)//复用性差 内置构造函数 12345var obj = new Object();obj.key = value;obj.key1 = value1;//复用性差 自定义构造函数 123456function Person()&#123; this.key = value; this.key1 = value1;&#125;var p = new Person(); 构造函数什么是构造函数构造函数就是一个函数，他和普通函数的区别在于，他一般被用来初始化对象！！ 构造函数的特点 首字母大写 一般和new关键字一起使用 不需要写return语句，默认返回new创建出来的对象 构造函数的执行过程 使用new关键字创建对象 调用构造函数，将构造函数中的this指向new创建出来的对象 执行构造函数中的代码，通过this为创建的对象新增属性和方法 默认的返回了new创建出来的对象 构造函数的注意事项 如果手动给构造函数写了return语句 如果return的是值类型的数据，对默认返回值不会有任何影响 如果return的是引用类型的数据，则返回的是该引用类型的数据 如果把构造函数当做普通函数来调用 this会指向window 返回值会和普通函数一样 构造函数写法存在的问题12345678910111213141516171819function Person()&#123; this.name = ""; //每次创建对象都会重新执行一次函数声明，也就是创建一个新的函数 //每个对象中都会有这么一个方法，但是每个方法的功能都是一样的，所以造成资源浪费 this.sayHello = function()&#123; &#125;;&#125;//解决方案：// 将方法的声明提出来放到构造函数外面，每次给对象的方法赋值的时候，直接将外面声明好的函数直接赋值给对象的方法，这样，所有的对象就都共享同一个方法了function sayHello()&#123;&#125;funciton Person()&#123; this.name = ""; this.sayHello = sayHello;&#125;//这么解决会造成全局变量污染以及代码结构混乱的问题 原型原型的概念构造函数在创建出来的时候，系统会默认的帮构造函数创建并且关联一个空对象，这个对象就是原型 原型的作用在原型中的所有的属性和方法，可以被和其关联的构造函数创建出来的所有的对象共享！ 原型的访问方式 构造函数.prototype 对象.proto (有兼容性问题) 原型的使用方式 利用对象的动态特性，给系统创建好的默认的原型中新增属性和方法 1Person.prototype.name = ""; 直接给构造函数.prototype属性赋值一个新的对象！ 原型的使用注意事项 一般将需要共享的内容放在原型当中，对象特有的东西放在对象本身中 使用对象.属性获取对象的属性的时候，会先在对象本身进行查找，如果有就使用，如果没有，就会去原型中进行查找 使用对象.属性 = 值，给对象的属性赋值的时候，会直接在直接在对象本身进行查找，如果有，就修改，如果没有，就新增这个属性 在使用构造函数.prototype=新的对象的时候， 赋值之前创建的对象和赋值之后创建的对象的原型不一样 面向对象的三大特性 封装：将功能的具体实现封装在对象内部，只对外界暴露指定的接口，外界在使用的时候，只需要关心接口如何使用，而不需要关心对象内部功能的具体实现，这就是封装 （ATM，电脑） 继承：自己没有的东西，别人有，拿过来使用，就是继承（js中的继承是基于对象的！） 多态：js中没有多态！ 继承的实现方式 混入式继承（mix-in） 123456789var obj = &#123;&#125;;var obj1 = &#123; name: "", age: 18&#125;for(var k in obj1)&#123; obj[k] = obj1[k];&#125; 原型继承 直接将要继承的对象，赋值给构造函数的prototype属性，这样创建出来的所有的对象能够访问的原型就是这个要继承的对象，也就是说实现了继承！ 123456789function Person()&#123; &#125;var obj = &#123; name: "", age: 18&#125;Person.prototype = obj; 利用混入的方式，将要继承的对象中的所有的方法和属性，添加到构造函数默认的原型中去 12345678910function Person()&#123; &#125;var obj = &#123; name: "", age: 18&#125;for(var k in obj)&#123; Person.prototype[k] = obj[k];&#125; 经典继承 123456789101112131415161718//Object.createvar obj1 = &#123; name: "", age: 18&#125;var obj = Object.create(obj1);//创建出来一个新的对象obj，obj的原型就是obj1function myCreate(obj)&#123; if(Object.create)&#123; return Object.create(obj); &#125;else&#123; function F()&#123;&#125; F.prototype = obj; return new F(); &#125;&#125; 如何安全的扩展内置对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//我想随便创建一个数组出来，都可以直接使用该数组对象.sayHello调用方法// Array.prototype.sayHello = function()&#123;// console.log("我是一个小数组！！");// &#125;// var arr = []; //var arr = new Array();// arr.sayHello();// var arr1 = [];// arr1.sayHello();// Array.prototype.sayHello = 123;// var arr3 = new Array;// arr3.sayHello();//如果直接在内置对象上进行修改，修改Array，或者说修改Array.prototype, 由于Array，Array.prototype是被所有人共享的，大家都在使用，自己的修改会对别人产生影响，如果别人和我们做了一样的修改，那么就会产生冲突！！ 所以直接修改内置对象的方式不可取！！！//我们可以自己定义一个构造函数，让这个构造函数的原型,prototype很属性指向一个数组对象，那么之后对于这个数组对象的更改，不会影响到别人，而且，数组对象中有数组所有的方法， 我们通过自己的构造函数创建出来的对象，就既有我们自己新增的方法，又有数组本身的方法！function MyArray()&#123;&#125;MyArray.prototype = [];MyArray.prototype.sayHello = function()&#123; console.log("我又是一个小数组！！")&#125;var arr = new MyArray();//可以调用数组中的方法arr.sayHello();arr.push(5);arr.push(2);arr.push(3);arr.sort(function()&#123; return Math.random()-0.5;&#125;);console.log(arr);]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>oriented object programming</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp使用方法总结]]></title>
    <url>%2F2017%2F07%2F07%2Fgulp%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[gulp使用方法总结需要安装的内容安装nodehttps://nodejs.org/zh-cn/ 装完node之后会自动装好npm, 通过npm安装cnpmnpm install -g cnpm 安装全局的gulp命令cnpm install -g gulp-cli 初始化项目的npm包管理文件cnpm init -y 给当前项目下载gulp相关的包cnpm install gulp -D 给当前项目创建一个gulp的任务文件 guilpfile.js在这个文件中可以创建各种类型的任务，执行gulp命令的时候，会自动来这个文件中查找任务进行执行 在gulpfile.js中创建任务 引入gulp模块 使用gulp.task方法创建任务 使用gulp.src方法读取要操作的文件 方法的参数可以是一个文件的路径，也可以用数组传多个文件的路径，还可以写文件路径的通配符 下载需要使用的gulp插件，比如uglify cnpm install uglify -D 在gulpfile.js中引入uglify模块 使用gulp.pipe方法将src方法获取到的文件传递给uglify插件进行使用 使用gulp.pipe方法将uglify插件处理后的文件交给gulp.dest方法进行存储 dest方法需要一个参数，这个参数就是文件最终存放的目录路径 在命令行中执行gulp命令 gulp js]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp的使用]]></title>
    <url>%2F2017%2F07%2F07%2Fgulp%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Gulp的安装和使用NodeNode是一个服务器端的js运行环境，还是当做web服务器来使用 npmNode Package Manager npm可以非常方便帮助我们管理项目开发当中的各种包资源！ npm init在项目文件夹中创建一个package.json文件，这个文件中包含当前项目所需的所有的包的信息 npm install 包名称@版本号 –save安装（下载）一个包 –save -S将当前的包信息保存到package.json–save-dev -D npm install会去将package.json中包含的所有的包进行下载安装！ npm info 包查看包的信息，包含版本信息 npm search 包名搜索相关的包！ browser-sync 的使用和gulp集成使用1234567891011121314151617181920//1. 为gulp安装browser-sync的包npm install browser-sync --save-dev//2. 在gulpfile中应用模块var browserSync = require("browser-sync").create();//3. 创建任务gulp.task("browser", function()&#123; //3.1 创建一个静态服务器 browserSync.init(&#123; server: &#123; //设置网站的根目录 baseDir: "./" &#125; &#125;) //3.2 监视文件的变化，执行指定的任务并且刷新浏览器 gulp.watch("要监视的文件", ["需要在文件改变后执行的任务"]); gulp.watch("要监视的文件", browserSync.reload);&#125;) 单独使用browser-sync12345//1. 全局安装browser-syncnpm install -g browser-sync//2. 执行browsersync命令browser-sync start --server --files "*.js, *.html, *.less" gulp的使用步骤12345678910111213141516171819202122232425262728//1. 全局安装gulp命令npm install -g gulp-cli//2. 在本地文件夹安装gulp相关的包//安装之前先执行以下 npm init -y这个命令生成一个package.json//要不然会把文件安装到用户根目录npm install gulp --save-devnpm install gulp -D//3. 创建一个gulpfile.js//4. 在gulpfile.js中引入gulp包var gulp = require("gulp");//5. 在gulpfile.js中创建新的任务gulp.task("任务名称", function()&#123; //任务内容 //5.1 操作哪些文件，就是用gulp.src方法去读取文件,若操作的文件有多个的话可以使用数组,或者是某个路径下的*.js gulp.src("./*.js") //5.2 通过gulp.pipe方法，将读取到的文件传递给下一个工作项(插件) .pipe(uglify()) //5.3 再通过pipe方法，将压缩好的内容传递给下一个工作项 //gulp.dest 是用来将当前管道中的内容保存到指定的位置，如果这个位置不存在 //他会自己创建的，文件名不需要指定，他会使用原来的文件名 .pipe(gulp.dest("./dist"))&#125;) gulp插件的使用过程12345678910//1. 下载插件包npm install 插件包名称 -D//2. 查看插件的文档 npmjs.com 搜索插件名称//3. 引入插件包var uglify = require("uglify");//4.在管道中使用插件.pipe(uglify()) gulp-rev]]></content>
      <categories>
        <category>javascript</category>
        <category>webfront</category>
      </categories>
      <tags>
        <tag>gulp</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化的总结]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[模块化CommonJSjs代码的模块化标准，不适用于前端开发，NodeJS在使用该标准实现模块化 AMDAsync Module Definition 异步模块定义 尽可能早的加载所有需要用到的模块，模块的加载都是异步的，如果要在模块加载完成后，利用模块中的内容实现某些功能，需要将代码写在 require的第二个参数的回调函数中12345678 //正确的写法 require(["views/assets/jquery/jquery"],function(value))&#123; console.log(value); //错误的写法 require(["views/assets/jquery/jquery"]); //因为加载是异步的,执行下面的代码console.log(value)的时候,第三方块的内容还没有加载完成,所以value是undefined; console.log(value);&#125; require.js CMDCommon Module Definition 通用模块定义 尽可能晚的加载模块，哪里用到了模块再去加载 sea.js ## require.js实现模块化 定义模块12345678//**依赖项是个数组**define(["当前模块的依赖项"...], function(使用形参接收依赖项的返回值)&#123; //当前模块中要实现的功能 //当前模块如果要提供内容给模块调用者使用，就需要通过return语句将需要体用给别人的内容进行返回 return 需要给别人提供的内容;&#125;) 引用模块1234require(["模块路径/模块别名"...], function()&#123; //这个函数会在模块加载完成之后，被调用起来 //如果想在模块加载完成后实现某些功能，那么代码都写到这个函数中！&#125;) data-main在引用require.js的script标签中可以通过data-main指定一个入口文件，这个入口文件中的内容，会在reuqirejs加载完毕之后，被自动执行。 data-main指定的这个文件是异步加载的！所以在下面如果有使用这个文件中相关内容的代码，就不能够保证执行正常 路径的说明 如果直接使用script在html当中引入模块，那么模块的路径查找会以当前html文件作为基础。 （没有配置baseUrl，也没有data-main属性） 如果使用data-main属性，那么这时候的模块路径查找，会以入口文件所在的路径作为基础去查找（没有设置baseUrl） 如果通过require.config()配置了baseUrl，那么所有的模块的路径查找，都会以这个baseUrl做为基础！ require.config方法的说明这个方法主要用来配置requirejs相关的内容 123456789101112require.config(&#123; //配置基础路径，所有的模块查找都以这个路径为基础 //这个路径一般情况下配置为绝对路径，并且设置为所有模块共享的路径 baseUrl: "/", //paths可以用来为单个路径设置别名，以后在使用模块的时候，直接使用别名即可，不需要再写完整的路径了 //如果模块是一个具名模块，那么这个别名一定要和具名模块的名称一致 //.js 不要！！！ paths: &#123; "jquery": "views/assets/jquery/jqeury.min" &#125;&#125;); 如何加载第三方内容实现了模块化的第三方内容加载直接使用require，就像使用正常模块一样即可！ 未实现模块化的第三方内容加载 需要考虑该内容是否有依赖项 需要考虑该内容是否有返回值（是否要提供内容给外部使用）如果有依赖项，需要通过require.config方法配置该模块的依赖项 1234567891011121314151617181920212223require.config(&#123; baseUrl: "/", paths: &#123; "jquery": "views/assets/jquery/jqeury.min", "animate": "animate/animate" &#125;, //配置的是第三方内容的依赖项以及输出项 shim: &#123; //模块别名： 配置信息 "animate": &#123; //deps属性可以用来配置**依赖项是个数组**; deps: ["jquery"], //export可以配置输出项 //输出项的内容其实就是在第三方内容中去查找和配置名称相对应的全局变量，将其值作为模块的输出值！ //exports后边的值是个**字符串**,require函数会在第三方的块里边去寻找全局变量,然后将全局变量的值返回 exports: "animate" &#125; &#125;&#125;);//用require函数调用实现和未实现模块化的内容也可以使用回调函数来引用模块的返回值require(["animate"],function(animate)&#123; animate();&#125;); 如果第三方内容没有实现模块化，并且没有依赖项，也没有输出项，直接require即可！！！ 具名模块匿名模块具名模块有名字123define("名字", [], function()&#123; &#125;) 匿名模块没名字123define([], function()&#123; &#125;)]]></content>
      <categories>
        <category>web</category>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[具名模块和匿名模块]]></title>
    <url>%2F2017%2F06%2F29%2F%E5%85%B7%E5%90%8D%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%BF%E5%90%8D%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[具名模块和匿名模块匿名模块123define([], function()&#123; &#125;) 具名模块123define("a", [], function()&#123; &#125;) 模块在声明的时候，给define传递个第一个参数可以是该模块的名称 在config中做配置的时候，别名尽量和具名模块的声明中的模块名称保持一致！可以保证不出错！！！]]></content>
      <categories>
        <category>web</category>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的模块化]]></title>
    <url>%2F2017%2F06%2F29%2Fjavascript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[模块化简单的使用js文件作为模块的缺陷 全局变量污染 引用js文件的时候，次序非常重要，而且比较麻烦 模块化的优势 可以将公共的部分定义成模块，方便复用 解决全局变量污染的问题 模块之间的依赖关系，非常明确，而且在应用模块的时候，根本不需要考虑依赖的先后顺序问题。 前端模块化模块化的标准 CommonJS: 是一个模块化的标准。Node.js在使用的一个模块化的标准 AMD: Async Module Definition, 在CommonJS基础上衍生出来的适用于前端开发中的模块化标准 AMD. 尽早将所有的模块全部加载进来 require.js CMD: Common Module Definition在CommonJS基础上衍生出来的适用于前端开发中的模块化标准 CMD. 用到之的时候再加载， as lazy as possible sea.js AMD没有明显的BUG，CMD明显没有BUG 模块化的是实现（require.js）require.js 只是一个js文件，这个js文件可以帮助我们实现前端模块化，他遵循的标准就是AMD标准。 定义模块1234define(function()&#123; //模块中所有的内容 console.log("Hello, 我是一个模块");&#125;) 引用模块1require(["模块的名称"]) 注意事项如果模块只是执行一些代码实现指定的功能，那么直接引用该模块，功能即可实现。但是如果模块的存在是为了给我们提供一些方法，对象，其他的内容让我们使用的话，就需要给这个模块一个产出，使用return语句将要提供给别人使用的内容进行返回，使用该模块的使用，需要在require的第二个参数的函数中书写一个形参来接收这个内容，就能达到使用的效果了！ 模块依赖项的处理如果定义一个模块的时候，这个模块要依赖于其他模块来实现，那么我们需要给这个模块指定依赖项 define([“依赖项1”,”依赖项2”…”依赖项N”], function(){ //模块的功能代码}) 如果模块的依赖项有给模块提供内容使用，那么需要在当前模块的回调函数中添加形参来接收依赖项模块的返回值，这里的形参和依赖项是一一对应的，如果存在好多依赖项，有的依赖项有产出，有的没有，那我们一般会将所有有产出的依赖项放在前面，没有的放在后面，这样可以省略掉没有产出模块的形参 requirejs的入口文件设置data-main可以给请求requirejs的script标签设置一个data-main属性，这个属性中放的是一个文件的路径，在requirejs加载完毕之后，会自动去执行data-main这个路径中指向的文件中的js代码！ data-main中的内容是异步加载的，如果下面有要基于data-main的功能实现的内容，那么requirejs不能保证data-main是在下面的内容之前执行的 模块路径查找的问题 如果直接在html文件中书写script标签，在标签内使用require来加载某个模块，那么会以当前的这个html文件作为参照，去找相对路径 如果我们是在入口文件中使用require加载的模块，那么这个时候是参照data-main指定的这个入口文件所在的目录来找模块的路径的！ 如果通过config指定了requirejs的baseUrl，那么所有的模块路径查找都会以这个baseUrl作为基础，去查找 requirejs可以通过config来配置一些内容baseUrlrequire.config({ //所有模块的路径查找，都会以这个baseUrl指定的路径为基础 //一般情况下就是找所有模块都能够共享的目录，作为baseUrl baseUrl: “”, //paths属性可以为每一个模块配置别名 //以后在使用模块的时候，不需要再去写那么长的真实路径了，而直接使用别名即可 paths: { //键： 别名名称 //值： 真实的模块路径 &quot;xm&quot;: &quot;modules1/modules2/modules3/moduleXM&quot; } });]]></content>
      <categories>
        <category>web</category>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>moduleify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中跨域的概念]]></title>
    <url>%2F2017%2F06%2F27%2Fjavascript%E4%B8%AD%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[同源策略 协议 域名 端口号 http://studyit.comhttp://www.studyit.com 在ajax请求中，如果所在的网页的域名和要请求的数据的域名产生的跨域，那么XHR对象的请求，会因为浏览器的同源策略而被阻断 ajax 请求中跨域问题的解决方案 jsonp返回的数据格式： 函数名({}) 12345678910111213141516171819202122232425262728293031323334 //平时写一个script标签 src属性赋值一个连接 //浏览器在解析到这个script标签的时候，会向src所指向的这个地址发送一个请求 //将请求下来的数据，当做js代码直接执行！ function jsonp(url, success)&#123; //随机生成一个函数名 var cbName = "jsonp" + parseInt(Math.random() * 100000000000); //把用户传递进来的这个回调函数，以随机生成的函数名作为名字存放到全局 //以便请求完成之后，直接调用 window[cbName] = success; var script = document.createElement("script"); script.src = url + "?callback="+cbName; document.body.appendChild(script); &#125; jsonp("http://bxg7.com/jsonp.php", function(data)&#123; console.log(data); &#125;)&lt;!-- more --&gt; jsonp("http://bxg7.com/jsonp.php", function(data)&#123; console.log(data); &#125;) //在jQuery的ajax函数中也可以通过jsop的属性来自动生成的回调函数命名 $.ajax(&#123; url: "http://bxg7.com/jsonp.php", //指定了数据请求要以jsop的形式进行 dataType: "jsonp", jsonp: "cb", success: function(data)&#123; console.log(data); &#125; &#125;); 后台给响应头加上Access-Control-Allow-Origin: * 反向代理3.1 打开httpd.conf找到如下两行 12#LoadModule proxy_module modules/mod_proxy.so#LoadModule proxy_http_module modules/mod_proxy_http.so 去掉前面的#，变成如下形式12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so 3.2 打开httpd-vhosts.conf找到要配置的域名的节点在virtualhost 节点中新增如下两行 12ProxyRequests offProxyPass /api http://api.botue.com http://studyit.com 在这个域名中要发送一个ajax请求 http://api.botue.com]]></content>
      <categories>
        <category>frontend</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WAMP虚拟服务器的环境配置]]></title>
    <url>%2F2017%2F06%2F27%2FWAMP%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[wampwindows apache mysql php 配置 没有开启vhosts配置的情况下httpd.confDocumentRoot: 网站的根目录 123&lt;Directory "网站根目录"&gt; # 权限信息&lt;/Directory&gt; 随便通过哪个域名，只要是访问的本机，都会打开这个根目录中的文件 开启了vhosts的情况 2.1 开启vhosts配置找到httpd.conf中的#Include conf/extra/httpd-vhosts.conf去掉前面的#Include conf/extra/httpd-vhosts.conf 2.2 为每个域名配置指定的根目录 一个域名要配置下面的两个节点要改的内容一共4个 DocumentRoot 域名的根目录 ServerName 域名 ServerAlias www.域名 Directory 后面的路径要改成域名的根目录 这一步是在做权限配置1234567891011121314&lt;VirtualHost *:80&gt; DocumentRoot "网站根目录" ServerName 域名 ServerAlias www.域名 ErrorLog "logs/dummy-host.example.com-error.log" CustomLog "logs/dummy-host.example.com-access.log" common&lt;/VirtualHost&gt;&lt;Directory "网站根目录"&gt; Options Indexes FollowSymLinks AllowOverride all Order Deny,Allow Allow from all&lt;/Directory&gt; 给本机hosts文件中添加域名ip的映射找到hosts文件“c:\windows\system32\drivers\etc\hosts”在文件中追加1234ip 域名127.0.0.1 studyit.com127.0.0.1 www.studyit.com 省略掉index.php的配置方式打开httpd.conf配置文件 找到#LoadModule rewrite_module modules/mod_rewrite.so去掉#LoadModule rewrite_module modules/mod_rewrite.so 将.htaccess 放到网站根目录和views同级 即可]]></content>
      <categories>
        <category>javascript</category>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>虚拟服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装liver-sever的步骤及如何将md文件转换成html文件]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%AE%89%E8%A3%85liver-sever%E7%9A%84%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[live-sever 的安装步骤 需要安装node(可以从百度上搜索下载) 打开命令提示符(cmd) 2.1 windows + r 可以打开运行窗口 2.2 输入cmd 敲回车 2.3 黑框框就出现了 在黑框框中输入以下命令, 命令运行成功之后live-server就装好了（这一步要联网） 1npm install live-server -g 打开你的html文件所在的目录，按住shift键，点击鼠标右键，选择在此处打开命令窗口又会出现一个黑框框， 在黑框框中输入如下命令 1live-sever 浏览器会自动打开 转md为html的方式 打开命令提示符（cmd 2.1 windows + r 可以打开运行窗口 2.2 输入cmd 敲回车 2.3 黑框框就出现了 在黑框框中输入以下命令, 1npm install -g i5ting_toc 打开你的md文件所在的目录，按住shift键，点击鼠标右键，选择在此处打开命令窗口又会出现一个黑框框， 在黑框框中输入如下命令 12i5ting_toc -f 文件名 -o//文件名要加后缀(可以用tab键来自动匹配对应的文件,命令中的空格就相当于代码中的空格) 浏览器会自动打开！ (文件夹中会多一个preview的文件夹，生成html就在里面)]]></content>
      <categories>
        <category>webFront</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>live-sever</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客的说明]]></title>
    <url>%2F2017%2F06%2F25%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[hexo 安装hexonpm install hexo-cli -g 创建一个博客文件夹在文件夹中执行 hexo init 在文件夹中直接执行 hexo s 在本地测试网页效果 新建文章hexo new “文章名称” 这句命令执行完毕之后，会在source/_posts/ 中生成以文章名为文件名的markdown文件 编辑文章找到对应的markdown文件，编辑内容即可 生成htmlhexo g 执行这条命令之后，会在public目录下生成所有的静态页面，只要将该目录下所有的文件进行发布，发布到github上，就可以通过github的静态页面托管服务来访问页面了 如何使用hexo d 来发布网站呢 安装 hexo-deployer-git npm install hexo-deployer-git –save 配置网站根目录下面的_config.yml 配置最下面的deloy节点 deploy: - type: git repo: github静态页面托管项目的地址 2.1 在public目录下执行 git init 并进行一次提交 按照正常流程创建博客， 编辑博客 执行hexo g 在 public 目录下去执行 hexo d]]></content>
      <categories>
        <category>webfrant</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>shell</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh协议介绍]]></title>
    <url>%2F2017%2F06%2F25%2Fssh%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[ssh协议介绍协议的介绍安全shell协议，此协议一般用作服务器之间的加密登录 http://域名:端口号/目录路径?参数=值#哈希值 git@github.com:avakpan/test1.git 用户名@域名:路径 加密算法对称性加密算法 非对称性加密算法 服务器免密登录如何实现因为在和服务进行通信的时候，会将本机的公钥顺带着发给服务器，如果我们之前就将自己的公钥添加到了服务器的允许登录的列表中，那么服务器在接收到我们的登录请求后，进行公钥的对比，如果一致，就允许登录！ 步骤如下： 在自己的电脑上生成秘钥 ssh-keygen -t rsa 登录服务器，将自己电脑中的公钥（默认路径在 c:\users\用户名.ssh\rsa_id.pub）中的内容，存储到服务器中的.ssh文件夹下的authorized_keys中 github免密设置 在自己的电脑上生成秘钥（如果没有的话） 在用户根目录中的.ssh文件夹中找到rsa_id.pub这个文件，复制里面所有的内容 打开github，找到设置页面（头像下面有settings） 左边栏中有ssh keys and gpg keys 点他 右上角有一个绿色的 new ssh key 点他 在key文本中粘贴刚才第2步复制的内容，点击下面的 add ssh key 即可 123function f()&#123; console.log("hello blog");&#125;]]></content>
      <categories>
        <category>javascript</category>
        <category>webFront</category>
      </categories>
      <tags>
        <tag>ssh协议介绍</tag>
        <tag>服务器免密登录如何实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令详解(续)]]></title>
    <url>%2F2017%2F06%2F25%2Fgit%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3(%E7%BB%AD)%2F</url>
    <content type="text"><![CDATA[博学谷项目 第2天分支什么时候创建分支？分支主要用在多任务并行开发的情况下，每当要进行一个新任务的开发，就创建一新的分支来做！ 1. 创建分支git branch 分支名称git checkout -b 分支名称 2. 切换到分支git checkout 分支名称 3. 合并分支git merge 指定的分支将指定的分支合并到当前分支 4. 删除分支git branch -d 分支名称 5. 显示所有分支git branch 远程仓储远程仓库用来共享版本库，多人开发的时候使用 远程仓库其实是一个裸仓库 裸仓库：没有.git文件夹，直接将所有的版本库信息暴露在文件夹下裸仓库没有工作目录， 在裸仓库中不能进行开发工作 创建远程仓库git init –bare 获取远程仓库的版本git clone 远程仓库地址 本地文件夹名称 把本地版本推送到远程仓库git push 远程仓库地址 本地分支:远程分支 如果本地分支和远程分支同名，写一个即可git push origin master 从远程仓库获取更新后的版本git pull如果不写远程地址和分支名称，默认获取origin地址的master分支git pull 远程仓库地址 要pull的分支 git后悔的命令git 后悔的命令 建立并切换到分支recovery中, (git checkout -b recovery)然后在分支中运行命令 git log -g 找到所有的日志,然后使用 git reset –hard 版本号 将需要的版本恢复到刚才所创建的分分支上, 切换到主分支 git checkout master 在主分支上运行 git merge recovery 将分分支上恢复的内容合并到主分支上这样就完成了后悔操作 远程仓库地址管理 添加git remote add 别名 地址 删除git remote remove 别名 显示所有的git remote]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git bash 命令介绍]]></title>
    <url>%2F2017%2F06%2F25%2Fgit%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[复习昨天内容shell bash vicd change directorypwdls ls -l ls -a ls -al ls 文件夹路径touch touch 文件路径mkdir mkdir 文件夹路径rmdir rmdir 文件夹路径rm rm 文件（文件夹）路径catlessmvcptabecho&gt; &gt; 普通模式插入模式命令模式 版本控制工具本地集中式分布式 git一台电脑只需要执行一次git config –global user.name 用户名git config –global user.email 邮箱 一个项目只需要执行一次git init git status git add git commit git log git checkout git reset –hard 版本号 git push git clone]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分支的相关命令]]></title>
    <url>%2F2017%2F06%2F25%2F%E5%88%86%E6%94%AF%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[分支相关的命令创建分支git branch 分支名称 查看所有分支git branch 切换到指定分支git checkout 分支名 合并分支git merge 分支名将指定的分支 合并到 当前的分支 删除分支git branch -d 分支名称 删除分支的时候，如果分支修改的内容没有被合并，那么会提示不能删除，要删除需要合并，或者使用-D 创建并切换到新的分支git checkout -b 分支名 在分支进行切换之前，要对所有的内容进行一次add 和commit操作 master分支是在仓库初始化之后，第一次提交完成的时候才出现的！]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>git shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程仓库的概念]]></title>
    <url>%2F2017%2F06%2F25%2F%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[远程仓库的概念概念所有的程序员，都可以通过这个远程仓库来进行版本库的共享，达到所有人的代码一致的效果！ 如何创建一个远程仓库远程仓库是一个裸仓库 如何初始化一个裸仓库git init –bare 平时初始化仓库的时候，直接使用git init，那么会在文件夹下创建一个.git文件夹来保存版本库信息 但是使用git init –bare 的时候，仓库信息相关的所有的文件，都直接暴露在当前文件夹下，就相当于没有衣服，所以叫做裸仓库。 裸仓库（远成仓库）中不进行任何的开发工作，他只是用来做版本库共享的！ 一般情况下远程仓库的文件夹名要用.git作为结尾 将本地仓库推送到远程仓库git push 远程仓库的地址 本地分支名称:远程分支名称 如果本地分支名称和远程分支名称的名字一致，就可以直接写一个举个例子： git push 远程仓库地址 master 如何将远程仓库获取到本地git clone 远程仓库地址 本地文件夹名称]]></content>
      <categories>
        <category>frontEnd</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[播客]]></title>
    <url>%2F2017%2F06%2F25%2F%E6%92%AD%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博学谷项目 第2天分支什么时候创建分支？分支主要用在多任务并行开发的情况下，每当要进行一个新任务的开发，就创建一新的分支来做！ 1. 创建分支git branch 分支名称git checkout -b 分支名称 2. 切换到分支git checkout 分支名称 3. 合并分支git merge 指定的分支将指定的分支合并到当前分支 4. 删除分支git branch -d 分支名称 5. 显示所有分支git branch 远程仓储远程仓库用来共享版本库，多人开发的时候使用 远程仓库其实是一个裸仓库 裸仓库：没有.git文件夹，直接将所有的版本库信息暴露在文件夹下裸仓库没有工作目录， 在裸仓库中不能进行开发工作 创建远程仓库git init –bare 获取远程仓库的版本git clone 远程仓库地址 本地文件夹名称 把本地版本推送到远程仓库git push 远程仓库地址 本地分支:远程分支 如果本地分支和远程分支同名，写一个即可git push origin master 从远程仓库获取更新后的版本git pull如果不写远程地址和分支名称，默认获取origin地址的master分支git pull 远程仓库地址 要pull的分支 远程仓库地址管理 添加git remote add 别名 地址 删除git remote remove 别名 显示所有的git remote]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>